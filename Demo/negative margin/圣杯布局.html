<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>The Holy Grail of Layouts: Example #1: A List Apart</title>
    <style>

        body {
            min-width: 550px;         /* 2 x LC width + RC width */
        }

        #container {
            padding-left: 200px;      /* LC width */
            padding-right: 150px;     /* RC width */
        }

        #container .column {
            position: relative;
            float: left;
        }

        #center {
            width: 100%;
        }

        #left {
            width: 200px;             /* LC width */
            right: 200px;             /* LC width */
            margin-left: -100%;
        }

        #right {
            width: 150px;             /* RC width */
            margin-right: -100%;
        }

        footer {
            clear: both;
        }


        /*** Just for Looks ***/

        body {
            margin: 0;
            padding: 0;
            background: #FFF;
        }

        header, footer {
            font-size: large;
            text-align: center;
            padding: 0.3em 0;
            background: #999;
        }

        #left {
            background: #66F;
        }

        #center {
            background: #DDD;
        }

        #right {
            background: #F66;
        }

        #container .column {
            padding-top: 1em;
            text-align: justify;
        }
    </style>
</head>
<!--
(1)中间部分需要根据浏览器宽度的变化而变化，所以要用width: 100%;，这里设左中右向左浮动，因为中间width: 100%;，左栏和右栏根本没有位置上去
(2)把左栏  margin-left: -100%后，发现左栏上去了，因为负到出窗口没位置了，只能往上挪
(3)按第二步这个方法，可以得出它只要挪动窗口宽度那么宽就能到最左边了，利用负边距，把左右栏定位
(4)但由于左右栏遮挡住了中间部分，于是采用相对定位方法，各自相对于自己把自己挪出去，得到最终结果 -->

<body>
    <header>39 满幅的背景，定宽的内容</header>
    <div id="container">
        <!--  元素次序 中间主体部分必须放在左右元素之前-->
        <div id="center" class="column">
            <h1>难题</h1>
            <p>在过去的几年间，有一种网页设计手法逐渐流行起来，我将它称作背景 宽度满幅，内容宽度固定。这个设计的一些典型特征如下。  页面中包含多个大区块，每个区块都占据了整个视口的宽度，区块 的背景也各不相同。  内容是定宽的，即使在不同分辨率下的宽度不一样，那也只是因为 媒体查询改变了这个固定的宽度值而已。在某些情况下，不同区块 的内容也可能具有不同的宽度。 有时候，整个网页都是由这种风格的多个区块组成的（比如图 7-13， 或者像图 7-14 那样稍微含蓄一些）。不过在更多的情况下，页面中只有某个特定区域是以这个风格来设计的，最典型的就是页脚（参见图
                7-15）。
            </p>
            <p>要实现这种设计风格，最常见的方法就是为每个区块准备两层元素：外层 用来实现满幅的背景，内层用来实现定宽的内容。后者是通过 margin: auto 实现水平居中的。举例来说，采用这种设计的页脚通常需要把结构代码写成： 同时用 CSS 来设置这两层元素的样式： footer { background: #333; } .wrapper { max-width: 90rem; margin: 1em auto; } 看起来很眼熟对不对？目前绝大多数的网页设计师 / 工程师都是这样写
                的。难道为了这个效果就一定要添加一层额外的元素？我们能否在现代 CSS 的帮助下彻底抛弃这个累赘？
            </p>
            <p>解决方案 我们先来想一想，margin: auto 在这个场景下到底发挥了什么作用。 这条声明所产生的左右外边距实际上都等于视口宽度的一半减去内容宽度的 一半。由于百分比在这里是基于视口宽度来解析的（假设所有祖先元素都没 有显式指定宽度），我们可以把这个外边距的值表达为 50% - 45rem。实际 上，CSS 值与单位（第三版）（http://w3.org/TR/css-values-3/#calc）定义了一 HTML 图 7-14 在行程预订网站 kayak.com 上，
                这种设计风格是以一种极为含蓄 的方式应用到整个页面的 图 7-13 一个华丽的爱尔兰网站柯诺苏葡 萄园酒庄（http://conosur.ie）就 大量运用了这种设计手法 图 7-15 借宿网站 airbnb.com 在页脚中采 用了这个设计 个 calc() 函数，它允许我们在 CSS 中直接以这种简单的算式来指定属性的 值。如果用 calc() 取代原先的 auto，这个内层容器的样式就会变成： 之所以要在页脚内加一层容器元素，唯一的原因就是为了给它的 margin
                指定神奇的 auto 关键字，从而实现内容的水平居中布局。不过，现 在我们已经用 calc() 替代了这个神奇的 auto，而且这个新值实际上可以作 为一个通用的 CSS 长度值应用到任何一个接受长度值的属性上。这意味着 如果我们愿意，还可以把这个长度值应用到父元素的 padding 上，而整个效 果是保持不变的：
            </p>
        </div>

        <div id="left" class="column">
            <h2>This is the left sidebar.</h2>
            <p>图 7-14 在行程预订网站 kayak.com 上， 这种设计风格是以一种极为含蓄 的方式应用到整个页面的 图 7-13 一个华丽的爱尔兰网站柯诺苏葡 萄园酒庄（http://conosur.ie）就 大量运用了这种设计手法 图 7-15 借宿网站 airbnb.com 在页脚中采 用了这个设计</p>
        </div>

        <div id="right" class="column">
            <h2>This is the right sidebar.</h2>
            <p>别忘了在 calc() 函数中用 空白符把 - 和 + 隔起来，否则会 产生解析错误！这个看似怪异的 规则是为了向前兼容：在未来， calc() 可能会允许使用标识符， 而这些标识符本身可能会包含连 字符，容易与减号混淆。 ! 图 7-16 Mac 上流行的生产力工具 Alfred （http://alfredapp.com）也在官网 上广泛采用了这种设计风格
            </p>
        </div>

    </div>
    <footer>CSS 值与单位 http://w3.org/TR/css-values 相关规范.</footer>
</body>

</html>
